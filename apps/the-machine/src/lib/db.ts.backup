/**
 * The Machine - Database Access Layer
 * 
 * Provides type-safe access to Cloudflare D1 database.
 * All database operations go through this layer for consistency.
 */

import type { RiskAssessment } from './assessment';
import type { ConstraintCheck } from './constraints';

// --------------------- TYPES --------------------- //

export interface AuditLog {
  id: string;
  timestamp: Date;
  operator: string;
  action: string;
  category: 'assessment' | 'intervention' | 'system' | 'constraint-check';
  severity: 'info' | 'warning' | 'critical';
  details: string;
  metadata?: Record<string, unknown>;
  assessment_id?: string;
  constraint_check_passed?: boolean;
  constraint_violations?: string;
}

export interface Setting {
  key: string;
  value: string;
  updated_at: Date;
  updated_by: string;
  description?: string;
  value_type: 'number' | 'boolean' | 'string' | 'json';
  is_locked: boolean;
  previous_value?: string;
  change_reason?: string;
}

export interface OperatorSession {
  id: string;
  operator_id: string;
  operator_email?: string;
  operator_name?: string;
  started_at: Date;
  last_activity: Date;
  ended_at?: Date;
  ip_address?: string;
  user_agent?: string;
  session_token: string;
  is_active: boolean;
}

// --------------------- DATABASE INTERFACE --------------------- //

/**
 * Database interface for Cloudflare D1
 * This is injected via environment bindings
 */
export interface D1Database {
  prepare(query: string): D1PreparedStatement;
  dump(): Promise<ArrayBuffer>;
  batch<T = unknown>(statements: D1PreparedStatement[]): Promise<D1Result<T>[]>;
  exec(query: string): Promise<D1ExecResult>;
}

export interface D1PreparedStatement {
  bind(...values: unknown[]): D1PreparedStatement;
  first<T = unknown>(colName?: string): Promise<T | null>;
  run(): Promise<D1Response>;
  all<T = unknown>(): Promise<D1Result<T>>;
  raw<T = unknown>(): Promise<T[]>;
}

export interface D1Response {
  success: boolean;
  meta: Record<string, unknown>;
  error?: string;
}

export interface D1Result<T = unknown> {
  results: T[];
  success: boolean;
  meta: {
    served_by: string;
    duration: number;
    changes: number;
    last_row_id: number;
    changed_db: boolean;
    size_after: number;
    rows_read: number;
    rows_written: number;
  };
}

export interface D1ExecResult {
  count: number;
  duration: number;
}

// --------------------- ASSESSMENTS --------------------- //

export async function createAssessment(
  db: D1Database,
  assessment: RiskAssessment
): Promise<void> {
  const query = `
    INSERT INTO assessments (
      id, created_at, created_by,
      who_at_risk, harm_type, harm_description, time_frame, location, perpetrator,
      probability, severity, uncertainty, data_quality, rationale, risk_score, risk_level,
      options, recommendation, flags, status, operator_notes
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
  `;

  await db.prepare(query).bind(
    assessment.id,
    assessment.createdAt.toISOString(),
    assessment.createdBy,
    JSON.stringify(assessment.identification.whoAtRisk),
    assessment.identification.harmType,
    assessment.identification.harmDescription,
    assessment.identification.timeFrame,
    assessment.identification.location || null,
    assessment.identification.perpetrator || null,
    assessment.estimate.probability,
    assessment.estimate.severity,
    assessment.estimate.uncertainty,
    assessment.estimate.dataQuality,
    assessment.estimate.rationaleBrief,
    calculateRiskScore(assessment),
    getRiskLevel(calculateRiskScore(assessment)),
    JSON.stringify(assessment.options),
    assessment.recommendation || null,
    JSON.stringify(assessment.flags),
    assessment.status,
    assessment.operatorNotes || null
  ).run();
}

export async function getAssessment(
  db: D1Database,
  id: string
): Promise<RiskAssessment | null> {
  const result = await db.prepare(
    'SELECT * FROM assessments WHERE id = ?'
  ).bind(id).first<any>();

  if (!result) return null;

  return dbRowToAssessment(result);
}

export async function listAssessments(
  db: D1Database,
  options: {
    limit?: number;
    offset?: number;
    status?: string;
    riskLevel?: string;
    createdBy?: string;
  } = {}
): Promise<RiskAssessment[]> {
  let query = 'SELECT * FROM assessments WHERE 1=1';
  const bindings: unknown[] = [];

  if (options.status) {
    query += ' AND status = ?';
    bindings.push(options.status);
  }

  if (options.riskLevel) {
    query += ' AND risk_level = ?';
    bindings.push(options.riskLevel);
  }

  if (options.createdBy) {
    query += ' AND created_by = ?';
    bindings.push(options.createdBy);
  }

  query += ' ORDER BY created_at DESC';

  if (options.limit) {
    query += ' LIMIT ?';
    bindings.push(options.limit);
  }

  if (options.offset) {
    query += ' OFFSET ?';
    bindings.push(options.offset);
  }

  const { results } = await db.prepare(query).bind(...bindings).all<any>();

  return results.map(dbRowToAssessment);
}

export async function updateAssessmentStatus(
  db: D1Database,
  id: string,
  status: string,
  operatorNotes?: string
): Promise<void> {
  await db.prepare(
    'UPDATE assessments SET status = ?, operator_notes = ? WHERE id = ?'
  ).bind(status, operatorNotes || null, id).run();
}

// Helper function to convert DB row to RiskAssessment
function dbRowToAssessment(row: any): RiskAssessment {
  return {
    id: row.id,
    createdAt: new Date(row.created_at),
    createdBy: row.created_by,
    identification: {
      whoAtRisk: JSON.parse(row.who_at_risk),
      harmType: row.harm_type,
      harmDescription: row.harm_description,
      timeFrame: row.time_frame,
      location: row.location || undefined,
      perpetrator: row.perpetrator || undefined,
    },
    estimate: {
      probability: row.probability,
      severity: row.severity,
      uncertainty: row.uncertainty,
      dataQuality: row.data_quality,
      rationaleBrief: row.rationale,
    },
    options: JSON.parse(row.options),
    recommendation: row.recommendation || undefined,
    flags: JSON.parse(row.flags),
    status: row.status,
    operatorNotes: row.operator_notes || undefined,
  };
}

// --------------------- AUDIT LOGS --------------------- //

export async function createAuditLog(
  db: D1Database,
  log: Omit<AuditLog, 'id' | 'timestamp'>
): Promise<string> {
  const id = `log-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  const timestamp = new Date().toISOString();

  await db.prepare(`
    INSERT INTO audit_logs (
      id, timestamp, operator, action, category, severity, details,
      metadata, assessment_id, constraint_check_passed, constraint_violations
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
  `).bind(
    id,
    timestamp,
    log.operator,
    log.action,
    log.category,
    log.severity,
    log.details,
    log.metadata ? JSON.stringify(log.metadata) : null,
    log.assessment_id || null,
    log.constraint_check_passed !== undefined ? (log.constraint_check_passed ? 1 : 0) : null,
    log.constraint_violations || null
  ).run();

  return id;
}

export async function listAuditLogs(
  db: D1Database,
  options: {
    limit?: number;
    offset?: number;
    category?: string;
    severity?: string;
    operator?: string;
    search?: string;
  } = {}
): Promise<AuditLog[]> {
  let query = 'SELECT * FROM audit_logs WHERE 1=1';
  const bindings: unknown[] = [];

  if (options.category) {
    query += ' AND category = ?';
    bindings.push(options.category);
  }

  if (options.severity) {
    query += ' AND severity = ?';
    bindings.push(options.severity);
  }

  if (options.operator) {
    query += ' AND operator = ?';
    bindings.push(options.operator);
  }

  if (options.search) {
    query += ' AND (action LIKE ? OR details LIKE ?)';
    bindings.push(`%${options.search}%`, `%${options.search}%`);
  }

  query += ' ORDER BY timestamp DESC';

  if (options.limit) {
    query += ' LIMIT ?';
    bindings.push(options.limit);
  }

  if (options.offset) {
    query += ' OFFSET ?';
    bindings.push(options.offset);
  }

  const { results } = await db.prepare(query).bind(...bindings).all<any>();

  return results.map(dbRowToAuditLog);
}

function dbRowToAuditLog(row: any): AuditLog {
  return {
    id: row.id,
    timestamp: new Date(row.timestamp),
    operator: row.operator,
    action: row.action,
    category: row.category,
    severity: row.severity,
    details: row.details,
    metadata: row.metadata ? JSON.parse(row.metadata) : undefined,
    assessment_id: row.assessment_id || undefined,
    constraint_check_passed: row.constraint_check_passed === 1 ? true : row.constraint_check_passed === 0 ? false : undefined,
    constraint_violations: row.constraint_violations || undefined,
  };
}

// --------------------- SETTINGS --------------------- //

export async function getSetting(
  db: D1Database,
  key: string
): Promise<Setting | null> {
  const result = await db.prepare(
    'SELECT * FROM settings WHERE key = ?'
  ).bind(key).first<any>();

  if (!result) return null;

  return dbRowToSetting(result);
}

export async function listSettings(db: D1Database): Promise<Setting[]> {
  const { results } = await db.prepare(
    'SELECT * FROM settings ORDER BY key'
  ).all<any>();

  return results.map(dbRowToSetting);
}

export async function updateSetting(
  db: D1Database,
  key: string,
  value: string,
  updatedBy: string,
  changeReason?: string
): Promise<void> {
  // Check if locked
  const setting = await getSetting(db, key);
  if (setting?.is_locked) {
    throw new Error(`Setting "${key}" is locked and cannot be changed`);
  }

  // Get previous value
  const previousValue = setting?.value;

  await db.prepare(`
    UPDATE settings 
    SET value = ?, updated_by = ?, previous_value = ?, change_reason = ?
    WHERE key = ?
  `).bind(value, updatedBy, previousValue || null, changeReason || null, key).run();
}

function dbRowToSetting(row: any): Setting {
  return {
    key: row.key,
    value: row.value,
    updated_at: new Date(row.updated_at),
    updated_by: row.updated_by,
    description: row.description || undefined,
    value_type: row.value_type,
    is_locked: row.is_locked === 1,
    previous_value: row.previous_value || undefined,
    change_reason: row.change_reason || undefined,
  };
}

// --------------------- CONSTRAINT CHECKS --------------------- //

export async function createConstraintCheck(
  db: D1Database,
  check: {
    operator: string;
    actionDescription: string;
    context?: string;
    passed: boolean;
    violations?: string;
    assessmentId?: string;
    shouldShutdown: boolean;
  }
): Promise<string> {
  const id = `check-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  const timestamp = new Date().toISOString();

  await db.prepare(`
    INSERT INTO constraint_checks (
      id, timestamp, operator, action_description, context,
      passed, violations, assessment_id, should_shutdown
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
  `).bind(
    id,
    timestamp,
    check.operator,
    check.actionDescription,
    check.context || null,
    check.passed ? 1 : 0,
    check.violations || null,
    check.assessmentId || null,
    check.shouldShutdown ? 1 : 0
  ).run();

  return id;
}

// --------------------- HELPER FUNCTIONS --------------------- //

// Import from assessment.ts (duplicated here to avoid circular dependency)
function calculateRiskScore(assessment: RiskAssessment): number {
  const probValues = { 'very-low': 10, 'low': 25, 'medium': 50, 'high': 75, 'very-high': 90 };
  const sevValues = { 'minor': 10, 'moderate': 30, 'serious': 50, 'severe': 75, 'critical': 95 };
  
  const probScore = probValues[assessment.estimate.probability];
  const sevScore = sevValues[assessment.estimate.severity];
  
  return Math.round((probScore * 0.4) + (sevScore * 0.6));
}

function getRiskLevel(score: number): 'low' | 'medium' | 'high' | 'critical' {
  if (score >= 80) return 'critical';
  if (score >= 60) return 'high';
  if (score >= 40) return 'medium';
  return 'low';
}
